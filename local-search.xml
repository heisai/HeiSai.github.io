<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>STL学习笔记 1</title>
    <link href="/2022/11/26/STL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%80)/"/>
    <url>/2022/11/26/STL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%80)/</url>
    
    <content type="html"><![CDATA[<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><pre><code class="hljs">该节不会刻意的去讲解某一个知识点，只是记录平时不懂的问题</code></pre><h2 id="std-list-splice"><a href="#std-list-splice" class="headerlink" title="std::list::splice"></a>std::list::splice</h2><pre><code class="hljs">作用:将元素从一个列表转移到另一个列表</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">splice</span><span class="hljs-params">( const_iterator pos, list&amp; other )</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">splice</span><span class="hljs-params">( const_iterator pos, list&amp;&amp; other )</span></span>;  <span class="hljs-comment">//转移 other 整个队列到 pos 处后面</span><br><span class="hljs-comment">// pos: 起始位置        other:转移的列表</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">splice</span><span class="hljs-params">( const_iterator pos, list&amp; other, const_iterator it )</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">splice</span><span class="hljs-params">( const_iterator pos, list&amp;&amp; other, const_iterator it )</span></span>; <span class="hljs-comment">//转移other 队列具体的一个元素到pos 处后面</span><br><span class="hljs-comment">// pos: 起始位置        other:转移的列表    it:转移列表的具体元素</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">splice</span><span class="hljs-params">( const_iterator pos, list&amp; other,</span></span><br><span class="hljs-params"><span class="hljs-function">             const_iterator first, const_iterator last)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">splice</span><span class="hljs-params">( const_iterator pos, list&amp;&amp; other,</span></span><br><span class="hljs-params"><span class="hljs-function">             const_iterator first, const_iterator last )</span></span>; <span class="hljs-comment">//转移other 队列某一区间范围元素到具体的一个元素到pos 处后面</span><br><span class="hljs-comment">// pos: 起始位置        other:转移的列表    it:转移列表的起始位置       last: 转移列表的终止位置</span><br><br></code></pre></td></tr></table></figure><h3 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例:"></a>使用案例:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++">    <br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> 1</span><br>std::ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(std::ostream&amp; ostr, <span class="hljs-type">const</span> std::list&lt;<span class="hljs-type">int</span>&gt;&amp; list)<br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;i : list)<br>        ostr &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; i;<br><br>    <span class="hljs-keyword">return</span> ostr;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::list&lt;<span class="hljs-type">int</span>&gt; list1 = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>    std::list&lt;<span class="hljs-type">int</span>&gt; list2 = &#123;<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>&#125;;<br><br>    <span class="hljs-comment">//将list2 所有元素转移到 iter = std::next(list1.begin(),2) 后面</span><br>    <span class="hljs-keyword">auto</span> iter = list1.<span class="hljs-built_in">begin</span>();<br>    std::<span class="hljs-built_in">advance</span>(iter, <span class="hljs-number">2</span>);<br>    list1.<span class="hljs-built_in">splice</span>(iter, list2);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;list1:&quot;</span> &lt;&lt; list1 &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; <span class="hljs-comment">// 1 2 10 20 30 40 50 3 4 5</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;list2:&quot;</span> &lt;&lt; list2 &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; <span class="hljs-comment">//</span><br><br>    <span class="hljs-comment">//将list4某一个元素(list4.begin())转移到 iter = std::next(list3.begin(),2) 后面  </span><br>    std::list&lt;<span class="hljs-type">int</span>&gt; list3 = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>    std::list&lt;<span class="hljs-type">int</span>&gt; list4 = &#123;<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>&#125;;<br>    <span class="hljs-keyword">auto</span> iter1 = list3.<span class="hljs-built_in">begin</span>();<br>    std::<span class="hljs-built_in">advance</span>(iter1,<span class="hljs-number">2</span>);<br>    list3.<span class="hljs-built_in">splice</span>(iter1, list4,list4.<span class="hljs-built_in">begin</span>());<br>    std::cout&lt;&lt;<span class="hljs-string">&quot;list3:&quot;</span>&lt;&lt;list3&lt;&lt;std::endl; <span class="hljs-comment">// 1 2 10 3 4 5</span><br>    std::cout&lt;&lt;<span class="hljs-string">&quot;list4:&quot;</span>&lt;&lt;list4&lt;&lt;std::endl; <span class="hljs-comment">// 20 30 40 50</span><br><br>    <span class="hljs-comment">// 将list6 某一区间的元素转移到iter = std::next(list5.begin(),2) 后面</span><br>    std::list&lt;<span class="hljs-type">int</span>&gt; list5 = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>    std::list&lt;<span class="hljs-type">int</span>&gt; list6 = &#123;<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>&#125;;<br>    <span class="hljs-keyword">auto</span> iter2 = list5.<span class="hljs-built_in">begin</span>();<br>    std::<span class="hljs-built_in">advance</span>(iter2,<span class="hljs-number">2</span>);<br>    list5.<span class="hljs-built_in">splice</span>(iter2, list6,list6.<span class="hljs-built_in">begin</span>(),list6.<span class="hljs-built_in">end</span>());<br>    std::cout&lt;&lt;<span class="hljs-string">&quot;list5:&quot;</span>&lt;&lt;list5&lt;&lt;std::endl; <span class="hljs-comment">//1 2 10 20 30 40 50 3 4 5</span><br>    std::cout&lt;&lt;<span class="hljs-string">&quot;list6:&quot;</span>&lt;&lt;list6&lt;&lt;std::endl; <span class="hljs-comment">//</span><br><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>STL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c++并发编程 4-1</title>
    <link href="/2022/11/22/c++%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B4-1/"/>
    <url>/2022/11/22/c++%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B4-1/</url>
    
    <content type="html"><![CDATA[<h1 id="线程-任务与期望"><a href="#线程-任务与期望" class="headerlink" title="线程(任务与期望)"></a>线程(任务与期望)</h1><h2 id="任务与期望值关联一"><a href="#任务与期望值关联一" class="headerlink" title="任务与期望值关联一"></a>任务与期望值关联一</h2><h3 id="Async-的使用"><a href="#Async-的使用" class="headerlink" title="Async 的使用"></a>Async 的使用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">_Fty</span>, <span class="hljs-keyword">class</span>... _ArgTypes&gt;<br>    _NODISCARD future&lt;_Invoke_result_t&lt;<span class="hljs-type">decay_t</span>&lt;_Fty&gt;, <span class="hljs-type">decay_t</span>&lt;_ArgTypes&gt;...&gt;&gt; <span class="hljs-built_in">async</span>(<br>        launch _Policy, _Fty&amp;&amp; _Fnarg, _ArgTypes&amp;&amp;... _Args) &#123;<br>        <span class="hljs-comment">// manages a callable object launched with supplied policy</span><br>        <span class="hljs-keyword">using</span> _Ret   = _Invoke_result_t&lt;<span class="hljs-type">decay_t</span>&lt;_Fty&gt;, <span class="hljs-type">decay_t</span>&lt;_ArgTypes&gt;...&gt;;<br>        <span class="hljs-keyword">using</span> _Ptype = <span class="hljs-keyword">typename</span> _P_arg_type&lt;_Ret&gt;::type;<br>        _Promise&lt;_Ptype&gt; _Pr(<br>            _Get_associated_state&lt;_Ret&gt;(_Policy, _Fake_no_copy_callable_adapter&lt;_Fty, _ArgTypes...&gt;(<br>                                                    _STD forward&lt;_Fty&gt;(_Fnarg), _STD forward&lt;_ArgTypes&gt;(_Args)...)));<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">future</span>&lt;_Ret&gt;(_Pr._Get_state_for_future(), _Nil());<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li><p>参数1：启动选项：</p><pre><code class="hljs">  enum class launch   &#123; // names for launch options passed to async          async    = 0x1, //异步          deferred = 0x2 // 延迟  &#125;;</code></pre></li><li><p>参数2: 函数：</p><pre><code class="hljs">  一般函数  类成员函数  类的静态函数  lambda 函数  (用bind 绑定的函数)</code></pre></li><li><p>参数3：可变参数模板<br><em>案例:</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">task</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;num)</span></span><br><span class="hljs-function"></span>&#123;<br>    std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">5</span>));<br>    std::cout&lt;&lt;<span class="hljs-string">&quot;task run over&quot;</span>&lt;&lt;std::endl;<br>    std::cout&lt;&lt;std::this_thread::<span class="hljs-built_in">get_id</span>()&lt;&lt;std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">10</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-type">int</span> num  =<span class="hljs-number">10</span>;<br>        std::future&lt;<span class="hljs-type">int</span>&gt;relust = std::<span class="hljs-built_in">async</span>(std::launch::deferred,task,std::<span class="hljs-built_in">ref</span>(num));<br>        <span class="hljs-comment">//std::future&lt;int&gt;relust = std::async(std::launch::async,task,std::ref(num));</span><br>    async<br>        std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">3</span>));<br>        std::cout&lt;&lt;std::this_thread::<span class="hljs-built_in">get_id</span>()&lt;&lt;std::endl;<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;async:&quot;</span>&lt;&lt;relust.<span class="hljs-built_in">get</span>()&lt;&lt;std::endl;<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;numnber:&quot;</span>&lt;&lt;num&lt;&lt;std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><pre><code class="hljs">  std::launch::defered 的使用 表明函数调用被延迟到wait() 或者get() 函数调用时才执行，是串行的。  std::launch::async  表明函数必须在新的线程上执行。也就是说调用完async时 函数就已经在运行了，get()只不过是获取结果而已。      有两种情况：          1： 在调用get()的时候 线程已经运行完了 这个时候的get() 就只是简单的获取结果。          2： 在调用get()的时候，线程还没有运行完，这个时候get() 就会阻塞直到线程运行完位置。</code></pre></li></ul><h3 id="后续说明"><a href="#后续说明" class="headerlink" title="后续说明"></a>后续说明</h3><pre><code class="hljs">这不是让 std::future 与任务实例相关联的唯 一方式；你也可以将任务包装入 std::packaged_task&lt;&gt; 实例中，或通过编写代码的方式，使用 std::promise&lt;&gt; 类型模板显示设置值。与 std::promise&lt;&gt; 对比， std::packaged_task&lt;&gt; 具有更高层的抽象</code></pre><h2 id="任务与期望值关联二"><a href="#任务与期望值关联二" class="headerlink" title="任务与期望值关联二"></a>任务与期望值关联二</h2><h3 id="std-packaged-task-的使用"><a href="#std-packaged-task-的使用" class="headerlink" title="std::packaged_task 的使用"></a>std::packaged_task 的使用</h3><pre><code class="hljs">    类模板std::packaged_task包装任何Callable目标（函数、lambda 表达式、绑定表达式或另一个函数对象），    以便可以异步调用它。它的返回值或抛出的异常存储在共享状态中，可以通过std::future对象访问。</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">_Ret</span>, <span class="hljs-keyword">class</span>... _ArgTypes&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">packaged_task</span>&lt;_Ret(_ArgTypes...)&gt; &#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="案例："><a href="#案例：" class="headerlink" title="案例："></a>案例：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;future&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123; <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">pow</span>(x,y); &#125;<br><span class="hljs-comment">//lambada</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">task_lambda</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">std::packaged_task&lt;<span class="hljs-title">int</span><span class="hljs-params">(<span class="hljs-type">int</span>,<span class="hljs-type">int</span>)</span>&gt; <span class="hljs-title">task</span><span class="hljs-params">([](<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">return</span> std::pow(a, b);</span></span><br><span class="hljs-params"><span class="hljs-function">    &#125;)</span></span>;<br>    std::future&lt;<span class="hljs-type">int</span>&gt; result = task.<span class="hljs-built_in">get_future</span>();<br><br>    <span class="hljs-built_in">task</span>(<span class="hljs-number">2</span>, <span class="hljs-number">9</span>);<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;task_lambda:\t&quot;</span> &lt;&lt; result.<span class="hljs-built_in">get</span>() &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br><span class="hljs-comment">// bind</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">task_bind</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">std::packaged_task&lt;<span class="hljs-title">int</span><span class="hljs-params">()</span>&gt; <span class="hljs-title">task</span><span class="hljs-params">(std::bind(f, <span class="hljs-number">2</span>, <span class="hljs-number">11</span>))</span></span>;<br>    std::future&lt;<span class="hljs-type">int</span>&gt; result = task.<span class="hljs-built_in">get_future</span>();<br>    <span class="hljs-built_in">task</span>();<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;task_bind:\t&quot;</span> &lt;&lt; result.<span class="hljs-built_in">get</span>() &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br><br><br><br>    <span class="hljs-function">std::packaged_task&lt;<span class="hljs-title">int</span><span class="hljs-params">(<span class="hljs-type">int</span>,<span class="hljs-type">int</span>)</span>&gt; <span class="hljs-title">task1</span><span class="hljs-params">(std::bind(f, std::placeholders::_1,std::placeholders::_2))</span></span>;<br>    std::future&lt;<span class="hljs-type">int</span>&gt; result1 = task1.<span class="hljs-built_in">get_future</span>();<br>    <span class="hljs-built_in">task1</span>(<span class="hljs-number">2</span>,<span class="hljs-number">11</span>);<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;task_bind:\t&quot;</span> &lt;&lt; result1.<span class="hljs-built_in">get</span>() &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br><br>&#125;<br><span class="hljs-comment">// thread</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">task_thread</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">std::packaged_task&lt;<span class="hljs-title">int</span><span class="hljs-params">(<span class="hljs-type">int</span>,<span class="hljs-type">int</span>)</span>&gt; <span class="hljs-title">task</span><span class="hljs-params">(f)</span></span>;<br>    std::future&lt;<span class="hljs-type">int</span>&gt; result = task.<span class="hljs-built_in">get_future</span>();<br><br>    <span class="hljs-function">std::thread <span class="hljs-title">task_td</span><span class="hljs-params">(std::move(task), <span class="hljs-number">2</span>, <span class="hljs-number">10</span>)</span></span>;<br>    task_td.<span class="hljs-built_in">join</span>();<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;task_thread:\t&quot;</span> &lt;&lt; result.<span class="hljs-built_in">get</span>() &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">task_lambda</span>();<br>    <span class="hljs-built_in">task_bind</span>();<br>    <span class="hljs-built_in">task_thread</span>();<br>&#125;<br><br></code></pre></td></tr></table></figure><p><em>具体的使用场景，以及使用案例，用一个开源项目去呈现 threadpool</em><br><em><a href="https://github.com/heisai/threadpool">开源地址: https://github.com/heisai/threadpool</a></em></p><h2 id="线程中用到的函数讲解："><a href="#线程中用到的函数讲解：" class="headerlink" title="线程中用到的函数讲解："></a>线程中用到的函数讲解：</h2><h3 id="std-ref-和std-cref-的用法"><a href="#std-ref-和std-cref-的用法" class="headerlink" title="std::ref 和std::cref 的用法"></a>std::ref 和std::cref 的用法</h3><pre><code class="hljs">个人理解：std::ref 就是将左值转换成左值引用的作用：使用场景：    bind()  以及线程的使用 thread()  async() ...</code></pre><h4 id="举例：线程"><a href="#举例：线程" class="headerlink" title="举例：线程"></a>举例：线程</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">task</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;num)</span></span><br><span class="hljs-function"></span>&#123;<br>    std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">5</span>));<br>    std::cout&lt;&lt;<span class="hljs-string">&quot;task run over&quot;</span>&lt;&lt;std::endl;<br>    num +=<span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-type">int</span> num  = <span class="hljs-number">10</span>;<br>        std::future&lt;<span class="hljs-type">int</span>&gt;relust = std::<span class="hljs-built_in">async</span>(task,std::<span class="hljs-built_in">ref</span>(num));<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;async:&quot;</span>&lt;&lt;relust.<span class="hljs-built_in">get</span>()&lt;&lt;std::endl;<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;numnber:&quot;</span>&lt;&lt;num&lt;&lt;std::endl; <span class="hljs-comment">//20</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="举例：-bind"><a href="#举例：-bind" class="headerlink" title="举例： bind"></a>举例： bind</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; n1, <span class="hljs-type">int</span>&amp; n2, <span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; n3)</span></span><br><span class="hljs-function"></span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;In function: &quot;</span> &lt;&lt; n1 &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; n2 &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; n3 &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    ++n1; <span class="hljs-comment">// increments the copy of n1 stored in the function object</span><br>    ++n2; <span class="hljs-comment">// increments the main()&#x27;s n2</span><br>    <span class="hljs-comment">// ++n3; // compile error</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n1 = <span class="hljs-number">1</span>, n2 = <span class="hljs-number">2</span>, n3 = <span class="hljs-number">3</span>;<br>    std::function&lt;<span class="hljs-type">void</span>()&gt; bound_f = std::<span class="hljs-built_in">bind</span>(f, n1, std::<span class="hljs-built_in">ref</span>(n2), std::<span class="hljs-built_in">cref</span>(n3));<br>    n1 = <span class="hljs-number">10</span>;<br>    n2 = <span class="hljs-number">11</span>;<br>    n3 = <span class="hljs-number">12</span>;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Before function: &quot;</span> &lt;&lt; n1 &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; n2 &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; n3 &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    <span class="hljs-built_in">bound_f</span>();<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;After function: &quot;</span> &lt;&lt; n1 &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; n2 &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; n3 &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br><br>Before function: <span class="hljs-number">10</span> <span class="hljs-number">11</span> <span class="hljs-number">12</span><br>In function: <span class="hljs-number">1</span> <span class="hljs-number">11</span> <span class="hljs-number">12</span><br>After function: <span class="hljs-number">10</span> <span class="hljs-number">12</span> <span class="hljs-number">12</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CMake学习二</title>
    <link href="/2022/09/17/CMake%E5%AD%A6%E4%B9%A0%E4%BA%8C/"/>
    <url>/2022/09/17/CMake%E5%AD%A6%E4%B9%A0%E4%BA%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="Cmake-进阶使用"><a href="#Cmake-进阶使用" class="headerlink" title="Cmake 进阶使用"></a><em>Cmake 进阶使用</em></h1><h2 id="添加子目录（子工程–可执行文件）"><a href="#添加子目录（子工程–可执行文件）" class="headerlink" title="添加子目录（子工程–可执行文件）"></a>添加子目录（子工程–可执行文件）</h2><ul><li><p>指令</p><pre><code class="hljs">  将子目录添加到构建。  add_subdirectory(source_dir [binary_dir] [EXCLUDE_FROM_ALL])  将子目录添加到构建。source_dir 指定源 CMakeLists.txt 和代码文件所在的目录。如果它是相对路径，它  将相对于当前目录进行评估（典型用法），但它也可能是绝对路径。binary_dir指定放置输出文件的目录</code></pre></li><li><p>自己理解</p><pre><code class="hljs">  将source_dir 目录生成的东西（可执行文件， 库）添加到指定的目录，  可以搞多工程（一个主工程， 下面有多个子工程（可执行文件，库））</code></pre></li><li><p>使用案例：</p><pre><code class="hljs">  |-- CMakeLists.txt  |-- src  |   |-- CMakeLists.txt  |   |-- MyWidget.cpp  |   |-- MyWidget.h  |   `-- main.cpp  `-- test      |-- CMakeLists.txt      `-- main.cpp  // 总目录：  cmake_minimum_required(VERSION 3.5)  project(HELLO LANGUAGES  C CXX)  set(CMAKE_CXX_STANDARD 17)  set(CMAKE_CXX_STANDARD_REQUIRED ON)  ADD_SUBDIRECTORY(src)  ADD_SUBDIRECTORY(test)  =======================================================  // src 目录  file(GLOB_RECURSE SOURCE_FILES  ./*.cpp)                   # 添加 .cpp  file(GLOB_RECURSE HEADER_FILES  ./*.h)                     # 添加 .h  ADD_EXECUTABLE(hello main.cpp  $&#123;HEADER_FILES&#125; $&#123;SOURCE_FILES&#125;)  SET(EXECUTABLE_OUTPUT_PATH $&#123;PROJECT_BINARY_DIR&#125;/bin3)  ========================================================  // test 目录   ADD_EXECUTABLE(test main.cpp)  SET(EXECUTABLE_OUTPUT_PATH $&#123;PROJECT_BINARY_DIR&#125;/bin3)</code></pre></li><li><p>生成目录</p><pre><code class="hljs">  $ tree -d  .  |-- CMakeFiles  |   |-- 3.23.1  |   |   |-- CompilerIdC  |   |   |   `-- tmp  |   |   `-- CompilerIdCXX  |   |       `-- tmp  |   |-- CMakeTmp  |   `-- ShowIncludes  |-- bin3  |-- src  |   `-- CMakeFiles  |       `-- hello.dir  `-- test      `-- CMakeFiles          `-- test.dir</code></pre></li></ul><h2 id="指定地方保存二进制文件"><a href="#指定地方保存二进制文件" class="headerlink" title="指定地方保存二进制文件"></a>指定地方保存二进制文件</h2><ul><li><p><strong>方法一：通用情况</strong></p><pre><code class="hljs">  # 将生成的可执行程序输出到 &#123;build&#125;/bin  SET(EXECUTABLE_OUTPUT_PATH $&#123;PROJECT_BINARY_DIR&#125;/bin)  # 将生成的库文件输出到 &#123;build&#125;/bin  SET(LIBRARY_OUTPUT_PATH $&#123;PROJECT_BINARY_DIR&#125;/lib)  指最终生成的可执行程序 或者最终的共享库，不包含编译生成 的中间文件)</code></pre></li><li><p><strong>方法二：特殊情况(有子目录嵌套)</strong></p><pre><code class="hljs">  #将 src 目录下的二进制文件 输出到&#123;build&#125;/src 目录  ADD_SUBDIRECTORY(src)  #将 src 目录下的二进制文件 输出到&#123;build&#125;/test 目录  ADD_SUBDIRECTORY(test)</code></pre></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>CMake 工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Gtest入门介绍</title>
    <link href="/2022/09/09/Gtest%20%E5%AD%A6%E4%B9%A0(%E4%B8%80)/"/>
    <url>/2022/09/09/Gtest%20%E5%AD%A6%E4%B9%A0(%E4%B8%80)/</url>
    
    <content type="html"><![CDATA[<h1 id="Gtest入门介绍"><a href="#Gtest入门介绍" class="headerlink" title="Gtest入门介绍"></a><em>Gtest入门介绍</em></h1><h4 id="简单使用："><a href="#简单使用：" class="headerlink" title="简单使用："></a>简单使用：</h4><pre><code class="hljs">    //test function    int getdata(int n,int m)    &#123;        return  n+m;    &#125;    TEST(getdata, demon)    &#123;        EXPECT_EQ(1,1);  // 等于        EXPECT_NE(1,2);  //不等于        EXPECT_LE(1,2);  // 小于等于        EXPECT_LT(getdata(1,-1),2);  //小于        EXPECT_GT(getdata(1,2),1);   //大于        EXPECT_GE(getdata(1,2),1);   //大于等于        EXPECT_TRUE(1!=2); //判断true        EXPECT_FALSE(1==2); //判断true    &#125;    int main(int argc, char **argv)    &#123;        ::testing::InitGoogleTest(&amp;argc, argv);        return RUN_ALL_TESTS();    &#125;</code></pre><h4 id="复杂条件判断"><a href="#复杂条件判断" class="headerlink" title="复杂条件判断:"></a>复杂条件判断:</h4><pre><code class="hljs">    尽管 googletest 有一组丰富的断言，但它们永远不会是完整的，因为预测用户可能遇到的所有场景是不可能的（也不是一个好主意）。因此，有时用户不得不使用EXPECT_TRUE()检查一个复杂的表达式，因为缺少一个更好的宏。这样做的问题是没有向您显示表达式部分的值，因此很难理解出了什么问题。作为一种解决方法，一些用户选择自己构建失败消息，将其流式传输到EXPECT_TRUE(). 但是，这很尴尬，尤其是当表达式具有副作用或评估成本很高时。    googletest 为您提供了三种不同的选项来解决此问题：</code></pre><ul><li><p>使用现有的布尔函数</p><pre><code class="hljs">   如果您已经有一个返回的函数或仿函数bool（或可以隐式转换为的类型bool），您可以在谓词断言中使用它来免费打印函数参数  bool Factorial(int n,int m)  &#123;      return (n+m)&gt;5;  &#125;  TEST(judage,demon1)  &#123;      EXPECT_PRED2(Factorial,3,1);  &#125;</code></pre></li><li><p>使用返回 AssertionResult 的函数</p><pre><code class="hljs">  testing::AssertionResult IsEven(int data )  &#123;      if ((data % 2) == 0)          return testing::AssertionSuccess();      else          return testing::AssertionFailure() &lt;&lt; data &lt;&lt; &quot;%2!=0&quot;;  &#125;  int datavalue(int data)  &#123;      // do something      return data*data;  &#125;  TEST(getdata, demon2)  &#123;      EXPECT_TRUE(IsEven(10));      EXPECT_TRUE(IsEven(datavalue(5)));  &#125;</code></pre></li></ul><h4 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h4><pre><code class="hljs">TEST(getdata, demon2)&#123;    cout&lt;&lt;&quot;str compare&quot;&lt;&lt;endl;    EXPECT_STREQ(&quot;1234&quot;,&quot;1234&quot;);            //等于    EXPECT_STRNE(&quot;1234&quot;,&quot;12345&quot;);           //不等于    EXPECT_STRCASEEQ(&quot;qwer&quot;,&quot;QWER&quot;);        //忽略大小写等于    EXPECT_STRCASENE(&quot;qwer&quot;,&quot;QWERq&quot;);       //忽略大小写不等于&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Gtest</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CMake 学习(一)</title>
    <link href="/2022/09/08/CMake%E5%AD%A6%E4%B9%A0(%E4%B8%80)/"/>
    <url>/2022/09/08/CMake%E5%AD%A6%E4%B9%A0(%E4%B8%80)/</url>
    
    <content type="html"><![CDATA[<h1 id="Cmake-使用"><a href="#Cmake-使用" class="headerlink" title="Cmake 使用"></a><em>Cmake 使用</em></h1><h2 id="1：-最小案例："><a href="#1：-最小案例：" class="headerlink" title="1： 最小案例："></a>1： 最小案例：</h2><pre><code class="hljs">cmake_minimum_required(VERSION 3.5)project(Demon LANGUAGES C CXX)            // 设置工程名称 和 c c++ 语言set(CMAKE_CXX_STANDARD 17)                   //指定为C++17 版本set(CMAKE_CXX_STANDARD_REQUIRED ON)add_executable($&#123;PROJECT_NAME&#125; main.cpp) </code></pre><table><thead><tr><th>变量</th><th>解释</th></tr></thead><tbody><tr><td>LANGUAGES</td><td>支持语言</td></tr><tr><td>CMAKE_CXX_STANDARD</td><td>c++语言版本</td></tr><tr><td>PROJECT_NAME</td><td>工程名称</td></tr><tr><td>PROJECT_BINARY_DIR</td><td>执行程序目录</td></tr><tr><td>PROJECT_SOURCE_DIR</td><td>源文件目录</td></tr></tbody></table><pre><code class="hljs">PROJECT(projectname [CXX] [C] [Java])：你可以用这个指令定义工程名称,并可指定工程支持的语言,支持的语言列表是可以忽略的,默认情况表示支持所有语言。这个指令隐式的定义了两个 cmake 变量:&lt;projectname&gt;_BINARY_DIR 以及&lt;projectname&gt;_SOURCE_DIR,这里就是MESSAGE(STATUS &quot;This is BINARY dir &quot; $&#123;Demon_BINARY_DIR&#125;)MESSAGE(STATUS &quot;This is SOURCE dir &quot;$&#123;Demon_SOURCE_DIR&#125;)替代品：MESSAGE(STATUS &quot;This is BINARY dir &quot; $&#123;PROJECT_BINARY_DIR&#125;)MESSAGE(STATUS &quot;This is SOURCE dir &quot;$&#123;PROJECT_SOURCE_DIR&#125;)生成结果：    -- This is BINARY dir E:/GLTest/CMAKE/cmaketest/build    -- This is BINARY dir E:/GLTest/CMAKE/cmaketest</code></pre><h2 id="2：-生成一个库并添加："><a href="#2：-生成一个库并添加：" class="headerlink" title="2： 生成一个库并添加："></a>2： 生成一个库并添加：</h2><ul><li><p>第一种方法</p><pre><code class="hljs">  cmake_minimum_required(VERSION 3.5)  project(cmaketest LANGUAGES CXX)  set(CMAKE_CXX_STANDARD 17)  set(CMAKE_CXX_STANDARD_REQUIRED ON)  file(GLOB_RECURSE SOURCE_FILES  ./adddir/*.cpp)       # 递归遍历 添加 .cpp  file(GLOB_RECURSE HEADER_FILES  ./adddir/*.h)         # 递归遍历添加 .h  add_library (ADD  ./adddir/MyAdd.cpp)                 # 生成 add.lib 库  add_executable(cmaketest main.cpp $&#123;SOURCE_FILES&#125;)  target_link_libraries($&#123;PROJECT_NAME&#125; ADD)            # 链接调用 ADD.lib</code></pre></li><li><p>第二种方法：</p><pre><code class="hljs">  ├── CMakeLists.txt                      #父目录的CMakeList.txt  ├── main.cpp                            #源文件，包含main函数  ├── adddir                              #子目录      └── CMakeLists.txt                  #子目录的CMakeLists.txt      └── MyAdd.h                         #子目录头文件      └── MyAdd.cpp                       #子目录源文件  cmake_minimum_required(VERSION 3.5)  project(cmaketest LANGUAGES CXX)  set(CMAKE_CXX_STANDARD 17)  set(CMAKE_CXX_STANDARD_REQUIRED ON)  include_directories ($&#123;PROJECT_SOURCE_DIR&#125;/adddir)  add_subdirectory (adddir)  add_executable(cmaketest main.cpp $&#123;SOURCE_FILES&#125;)  target_link_libraries($&#123;PROJECT_NAME&#125; ADD)                    # 链接调用 ADD.lib  // adddir cmakelist  add_library (ADD  MyAdd.cpp)</code></pre><p>  <em>区别：</em></p><pre><code class="hljs">  第一种 add.lib 生成在和可执行程序在同一目录  第二种 add.lib 生成在可执行程序目录的 adddir 目录（add_subdirectory (adddir)）</code></pre></li></ul><h2 id="3：-项目中使用第三方库"><a href="#3：-项目中使用第三方库" class="headerlink" title="3： 项目中使用第三方库"></a>3： 项目中使用第三方库</h2><ul><li><p>使用场景：项目中使用OpenGl 第三放库（glfw）以及glad,glm 源文件</p></li><li><p>案例：</p><pre><code class="hljs">      cmake_minimum_required(VERSION 3.5)      project(opengl6 LANGUAGES  C CXX)      set(CMAKE_CXX_STANDARD 17)                          set(CMAKE_CXX_STANDARD_REQUIRED ON)      set(LIBDIR  ./OpenGl/glfw/lib)                                                  #设置库路径            set(INCLUDEDIR  ./OpenGl/glad/include ./OpenGl/glfw/include ./OpenGl/glm)       #设置头文件路径        link_directories($&#123;LIBDIR&#125;)                                    # 加载库路径        include_directories($&#123;INCLUDEDIR&#125;)                             # 加载头文件路径      file(GLOB_RECURSE SOURCE_FILES  ./src/*.cpp)                   # 添加 .cpp      file(GLOB_RECURSE HEADER_FILES  ./src/*.h)                     # 添加 .h        add_executable ($&#123;PROJECT_NAME&#125; main.cpp $&#123;HEADER_FILES&#125; $&#123;SOURCE_FILES&#125;)        # 将源代码添加到此项目的可执行文件。      add_library(GLAD ./src/glad.c)                                # 编译glad 库      set(LIBS glfw3 opengl32 GLAD)            target_link_libraries($&#123;PROJECT_NAME&#125; $&#123;LIBS&#125;)                # 链接 可执行文件 所需库</code></pre></li><li><p>讲解：</p><pre><code class="hljs">  1&gt; link_directories($&#123;LIBDIR&#125;)             # 加载库文件  2&gt; include_directories($&#123;INCLUDEDIR&#125;)      # 加载头文件  3&gt; SET 指令的语法是:  现阶段,你只需要了解 SET 指令可以用来显式的定义变量即可。      SET(VAR [VALUE] [CACHE TYPE DOCSTRING [FORCE]])  4&gt; MESSAGE 指令的语法是:   MESSAGE([SEND_ERROR | STATUS | FATAL_ERROR] &quot;message to display&quot;...)      这个指令用于向终端输出用户定义的信息,包含了三种类型:            SEND_ERROR,产生错误,生成过程被跳过。      SATUS,输出前缀为—的信息。      FATAL_ERROR,立即终止所有 cmake 过程.      MESSAGE(SEND_ERROR  &quot;SEND_ERROR&quot; )      CMake Error at CMakeLists.txt:8 (MESSAGE):          SEND_ERROR            MESSAGE(FATAL_ERROR &quot;FATAL_ERROR&quot; )            CMake Error at CMakeLists.txt:9 (MESSAGE):          FATAL_ERROR</code></pre></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>CMake 工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
